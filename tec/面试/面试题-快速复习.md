## Java

### 基础

#### 1. 为什么 String 类型要用 final 修饰？

Java 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。

James Gosling 还说迫使 String 类设计成不可变的另一个原因是安全，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使 String 类设计成不可变类的一个重要原因。

总结来说，使用 final 修饰的第一个好处是高效；第二个好处是安全。

#### 2. == 和 equals 的区别是什么？

== 对于基本数据类型来说，是用于比较 “值”是否相等的；
而对于引用类型来说，是用于比较引用地址是否相同的。

看 Java 源码，Object 中的 equals() 方法其实就是  == ，而 String 重写了 equals() 方法把它修改成比较两个字符串的值是否相等。

#### 3. String 和 StringBuilder、StringBuffer 有什么区别？

因为 String 类型是不可变的，所以在字符串拼接的时候如果使用 String 的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了 append 和 insert 方法可用于字符串的拼接，它使用 synchronized 来保证线程安全。

因为它使用了 synchronized 来保证线程安全，所以性能不是很高，于是在 JDK 1.5 就有了 StringBuilder，它同样提供了 append 和 insert 的拼接方法，但它没有使用 synchronized 来修饰，因此在性能上要优于 StringBuffer，所以在非并发操作的环境下可使用 StringBuilder 来进行字符串拼接。

#### 4. String 类型在 JVM 中是如何存储的？

String 常见的创建方式有两种，new String() 的方式和直接赋值的方式。

直接赋值的方式会先去字符串常量池中查找是否已经有此值，如果有则把引用地址直接指向此值，否则会先在常量池中创建，然后再把引用指向此值；

而 new String() 的方式一定会先在堆上创建一个字符串对象，然后再去常量池中查询此字符串的值是否已经存在，如果不存在会先在常量池中创建此字符串，然后把引用的值指向此字符串。

#### 5. JDK Proxy 和 CGLib 的区别有哪些？

JDK Proxy 是 Java 语言自带的功能，无需通过加载第三方类实现；
Java 对 JDK Proxy 提供了稳定的支持，并且会持续的升级和更新 JDK Proxy，例如 Java 8 版本中的 JDK Proxy 性能相比于之前版本提升了很多；
JDK Proxy 是通过拦截器加反射的方式实现的；
JDK Proxy 只能代理继承接口的类；
JDK Proxy 实现和调用起来比较简单；
CGLib 是第三方提供的工具，基于 ASM 实现的，性能比较高；
CGLib 无需通过接口来实现，它是通过实现子类的方式来完成调用的。

#### 6. 动态代理是如何实现的？

动态代理的常用实现方式是反射。但动态代理不止有反射一种实现方式，例如，动态代理可以通过 CGLib 来实现，而 CGLib 是基于 ASM（一个 Java 字节码操作框架）而非反射实现的。简单来说，动态代理是一种行为方式，而反射或 ASM 只是它的一种实现手段而已。

#### 7. 讲讲 Lombok 的原理

ombok 的实现和反射没有任何关系，前面我们说了反射是程序在运行期的一种自省（introspect）能力，而 Lombok 的实现是在编译期就完成了。

在编译期阶段，当 Java 源码被抽象成语法树（AST）之后，Lombok 会根据自己的注解处理器动态修改 AST，增加新的代码（节点），在这一切执行之后就生成了最终的字节码（.class）文件，这就是 Lombok 的执行原理。

#### 8. 动态代理和静态代理的区别？

态代理其实就是事先写好代理类，可以手工编写也可以使用工具生成，但它的缺点是每个业务类都要对应一个代理类，特别不灵活也不方便，于是就有了动态代理。

#### 9. 动态代理的常见使用场景

RPC 框架的封装、AOP（面向切面编程）的实现、JDBC 的连接等。

Spring 框架中同时使用了两种动态代理 JDK Proxy 和 CGLib，当 Bean 实现了接口时，Spring 就会使用 JDK Proxy，在没有实现接口时就会使用 CGLib，我们也可以在配置中指定强制使用 CGLib，只需要在 Spring 配置中添加 <aop:aspectj-autoproxy proxy-target-class="true"/> 即可。

### 集合

#### 1. HashMap 底层实现原理是什么？

在 JDK 1.7 中 HashMap 是以数组加链表的形式组成的，JDK 1.8 之后新增了红黑树的组成结构，当链表大于 8 并且容量大于 64 时，链表结构会转换成红黑树结构。

JDK 1.8 之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。

### 并发

#### 1. 线程的工作模式

先要创建线程并指定线程需要执行的业务方法，然后再调用线程的 start() 方法，此时线程就从 NEW（新建）状态变成了 RUNNABLE（就绪）状态，此时线程会判断要执行的方法中有没有 synchronized 同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为 BLOCKED（阻塞等待）状态，当其他线程使用完此锁之后，线程会继续执行剩余的方法。

当遇到 Object.wait() 或 Thread.join() 方法时，线程会变为 WAITING（等待状态）状态，如果是带了超时时间的等待方法，那么线程会进入 TIMED_WAITING（计时等待）状态，当有其他线程执行了 notify() 或 notifyAll() 方法之后，线程被唤醒继续执行剩余的业务方法，直到方法执行完成为止。

#### 2. start() 和 run() 的区别

1. 从 Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全；run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法

2. 从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法。

3. 它们可调用的次数不同，start() 方法不能被多次调用，否则会抛出java.lang.IllegalStateException；而 run() 方法可以进行多次调用，因为它只是一个普通的方法而已。

#### 3. 列举几个线程的常用方法

1. Thread.setPriority()：线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。
2. join()：在一个线程中调用 other.join() ，这时候当前线程会让出执行权给 other 线程，直到 other 线程执行完或者过了超时时间之后再继续执行当前线程。从源码中可以看出 join() 方法底层还是通过 wait() 方法来实现的。
3. yield()：看 Thread 的源码可以知道 yield() 为本地方法，也就是说 yield() 是由 C 或 C++ 实现的；yield() 方法表示给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示。

#### 4. 线程的 execute() VS submit()

execute() 和 submit() 都是用来执行线程池任务的，它们最主要的区别是，submit() 方法可以接收线程池执行的返回值，而 execute() 不能接收返回值。

submit() 方法可以配合 Futrue 来接收线程执行的返回值。它们的另一个区别是 execute() 方法属于 Executor 接口的方法，而 submit() 方法则是属于 ExecutorService 接口的方法。

#### 5. ThreadPoolExecutor 扩展

ThreadPoolExecutor 的扩展主要是通过重写它的 beforeExecute() 和 afterExecute() 方法实现的，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间。

#### 6. synchronized 和 ReentrantLock 的实现原理是什么？

synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的，synchronized 只允许同一时刻只有一个线程操作资源。

在 Java 中每个对象都隐式包含一个 monitor（监视器）对象，加锁的过程其实就是竞争 monitor 的过程，当线程进入字节码 monitorenter 指令之后，线程将持有 monitor 对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。

ReentrantLock 是 Lock 的默认实现方式之一，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。

synchronized 和 ReentrantLock 都提供了锁的功能，具备互斥性和不可见性。

#### 7. synchronized 和 ReentrantLock 有什么区别？

1. synchronized 是 JVM 隐式实现的，而 ReentrantLock 是 Java 语言提供的 API；
2. ReentrantLock 可设置为公平锁，而 synchronized 却不行；
3. ReentrantLock 只能修饰代码块，而 synchronized 可以用于修饰方法、修饰代码块等；
4. ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁；
5. ReentrantLock 可以知道是否成功获得了锁，而 synchronized  却不行。

#### 8. 讲一讲 JDK 1.6 锁优化

##### 自适应自旋锁

JDK 1.6 引入了自适应式自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自旋等待成功获取了锁，那么虚拟机就会认为，它下一次很有可能也会成功 (通过自旋获取到锁)，因此允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁时，可能会直接忽略掉自旋的过程，以避免浪费 CPU 的资源，这就是自适应自旋锁的功能。

##### 锁升级

锁升级其实就是从偏向锁到轻量级锁再到重量级锁升级的过程，这是 JDK 1.6 提供的优化功能，也称之为锁膨胀。

偏向锁是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的 ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如 Locking、Unlocking 等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过 -XX:-UseBiasedLocking 来禁用偏向锁以提高性能。

轻量锁是相对于重量锁而言的，在 JDK 1.6 之前，synchronized 是通过操作系统的互斥量（mutex lock）来实现的，这种实现方式需要在用户态和核心态之间做转换，有很大的性能消耗，这种传统实现锁的方式被称之为重量锁。

而轻量锁是通过比较并交换（CAS，Compare and Swap）来实现的，它对比的是线程和对象的 Mark Word（对象头中的一个区域），如果更新成功则表示当前线程成功拥有此锁；如果失败，虚拟机会先检查对象的 Mark Word 是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用了。当两个以上的线程争抢此锁时，轻量级锁就膨胀为重量级锁，这就是锁升级的过程，也是 JDK 1.6 锁优化的内容。

#### 9. 谈谈你对锁的理解？

锁是指在并发编程中，当有多个线程同时操作一个资源时，为了保证数据操作的正确性，我们需要让多线程排队一个一个地操作此资源，而这个过程就是给资源加锁和释放锁的过程，就好像去公共厕所一样，必须一个一个排队使用，并且在使用时需要锁门和开门一样。

锁的概念不止出现在 Java 语言中，比如乐观锁和悲观锁其实很早就存在于数据库中了。

##### 悲观锁和乐观锁

悲观锁指的是数据对外界的修改采取保守策略，它认为线程很容易会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用。

被 synchronized 修饰的代码块，在执行之前先使用 monitorenter 指令加锁，然后在执行结束之后再使用 monitorexit 指令释放锁资源，在整个执行期间此代码都是锁定的状态，这就是典型悲观锁的实现流程。

乐观锁和悲观锁的概念恰好相反，乐观锁认为一般情况下数据在修改时不会出现冲突，所以在数据访问之前不会加锁，只是在数据提交更改时，才会对数据进行检测。

Java 中的乐观锁大部分都是通过 CAS（Compare And Swap，比较并交换）操作实现的，CAS 是一个多线程同步的原子指令，CAS 操作包含三个重要的信息，即内存位置、预期原值和新值。如果内存位置的值和预期的原值相等的话，那么就可以把该位置的值更新为新值，否则不做任何修改。

CAS 可能会造成 ABA 的问题，ABA 问题指的是，线程拿到了最初的预期原值 A，然而在将要进行 CAS 的时候，被其他线程抢占了执行权，把此值从 A 变成了 B，然后其他线程又把此值从 B 变成了 A，然而此时的 A 值已经并非原来的 A 值了，但最初的线程并不知道这个情况，在它进行 CAS 的时候，只对比了预期原值为 A 就进行了修改，这就造成了 ABA 的问题。

ABA 的常见处理方式是添加版本号，每次修改之后更新版本号，拿上面的例子来说，假如每次移动箱子之后，箱子的位置就会发生变化，而这个变化的位置就相当于“版本号”，当某人进来之后发现箱子的位置发生了变化就知道有人动了手脚，就会放弃原有的计划，这样就解决了 ABA 的问题。

JDK 在 1.5 时提供了 AtomicStampedReference 类也可以解决 ABA 的问题，此类维护了一个“版本号” Stamp，每次在比较时不止比较当前值还比较版本号，这样就解决了 ABA 的问题。

##### 可重入锁

可重入锁也叫递归锁，指的是同一个线程，如果外面的函数拥有此锁之后，内层的函数也可以继续获取该锁。在 Java 语言中 ReentrantLock 和 synchronized 都是可重入锁。

##### 共享锁和独占锁

只能被单线程持有的锁叫独占锁，可以被多线程持有的锁叫共享锁。

独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 synchronized 就是独占锁，而 ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。

独占锁可以理解为悲观锁，当每次访问资源时都要加上互斥锁，而共享锁可以理解为乐观锁，它放宽了加锁的条件，允许多线程同时访问该资源。

#### 10. 线程池参数的设置原则

1、corePoolSize: 核心线程数

核心线程会一直存活，即使没有任务需要执行。
当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理。
设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。

先看下机器的CPU核数，然后分析下线程池处理的程序是 CPU 密集型还是 IO 密集型

CPU密集型：corePoolSize = CPU核数 + 1

IO密集型：corePoolSize = CPU核数 * 2

2、maximumPoolSize：最大线程数

当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务。
当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常。

3、keepAliveTime：线程空闲时间

当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize。
如果allowCoreThreadTimeout=true，则会直到线程数量=0。

4、queueCapacity：任务队列容量（阻塞队列）

当核心线程数达到最大时，新任务会放在队列中排队等待执行

5、allowCoreThreadTimeout：允许核心线程超时

6、rejectedExecutionHandler：任务拒绝处理器


### IO

### JVM

#### 1. JVM 内存布局
![[Pasted image 20230423145104.png]]

1. 堆（Java Heap） 也叫 Java 堆或者是 GC 堆，它是一个线程共享的内存区域，也是 JVM 中占用内存最大的一块区域，Java 中所有的对象都存储在这里。
2. 方法区（Method Area） 也被称为非堆区，用于和“Java 堆”的概念进行区分，它也是线程共享的内存区域，用于存储已经被 JVM 加载的类型信息、常量、静态变量、代码缓存等数据。
3. 程序计数器（Program Counter Register） 线程独有一块很小的内存区域，保存当前线程所执行字节码的位置，包括正在执行的指令、跳转、分支、循环、异常处理等。
4. 虚拟机栈也叫 Java 虚拟机栈（Java Virtual Machine Stack），和程序计数器相同它也是线程独享的，用来描述 Java 方法的执行，在每个方法被执行时就会同步创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。当调用方法时执行入栈，而方法返回时执行出栈。
5. 本地方法栈（Native Method Stacks）与虚拟机栈类似，它是线程独享的，并且作用也和虚拟机栈类似。只不过虚拟机栈是为虚拟机中执行的 Java 方法服务的，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

#### 2. 类加载

类的生命周期会经历以下 7 个阶段：

1. 加载阶段（Loading）
2. 验证阶段（Verification）
3. 准备阶段（Preparation）
4. 解析阶段（Resolution）
5. 初始化阶段（Initialization）
6. 使用阶段（Using）
7. 卸载阶段（Unloading）

其中验证、准备、解析 3 个阶段统称为连接（Linking）

#### 3. 在 Java 中可以作为 GC Roots 的对象有哪些

1. 所有被同步锁持有的对象，比如被 synchronize 持有的对象；
2. 字符串常量池里的引用（String Table）；
3. 类型为引用类型的静态变量；
4. 虚拟机栈中引用对象；
5. 本地方法栈中的引用对象。

#### 4. jvm常用指令

1. jps：查看所有java进程
2. jstack：查看所有线程
3. jmap 
	1. -histo ：查看所有的java对象
	2. -dump：导出堆的存储文件


#### 5. 如何查哪个进程的哪个线程占用cpu

1. top 查进程

2. top -hp 查线程

3. jstack 查线程

4. 如果是gc就查gc日志；如果是业务，就去查业务

#### 6. arthas 常用指令
1. 挂到Java进程上
2. dashboard
3. jvm
4. [heapdump](https://arthas.aliyun.com/doc/heapdump.html)
5. jad 反编译
6. redefine 

### 新特性


## 数据库

### MySQL

#### 1.如何选择数据库引擎？

选择数据库引擎要从实际的业务情况入手，比如是否需要支持事务？是否需要支持外键？是否需要支持持久化？以及是否支持地理位置存储以及索引等方面进行综合考量。

我们最常用的数据库引擎是 InnoDB，它是 MySQL 5.5.5 之后的默认引擎，其优点是支持事务，且支持 4 种隔离级别。

读未提交：也就是一个事务还没有提交时，它做的变更就能被其他事务看到。
读已提交：指的是一个事务只有提交了之后，其他事务才能看得到它的变更。
可重复读：此方式为默认的隔离级别，它是指一个事务在执行过程中（从开始到结束）看到的数据都是一致的，在这个过程中未提交的变更对其他事务也是不可见的。
串行化：是指对同一行记录的读、写都会添加读锁和写锁，后面访问的事务必须等前一个事务执行完成之后才能继续执行，所以这种事务的执行效率很低。

InnoDB 还支持外键、崩溃后的快速恢复、支持全文检索（需要 5.6.4+ 版本）、集群索引，以及地理位置类型的存储和索引等功能。

MyISAM 引擎是 MySQL 原生的引擎，但它并不支持事务功能，这也是后来被 InnoDB 替代为默认引擎的主要原因。MyISAM 有独立的索引文件，因此在读取数据方面的性能很高，它也支持全文索引、地理位置存储和索引等功能，但不支持外键。

InnoDB 和 MyISAM 都支持持久化，但 MEMORY 引擎是将数据直接存储在内存中了，因此在重启服务之后数据就会丢失，但它带来的优点是执行速度很快，可以作为临时表来使用。

我们可以根据实际的情况设置相关的数据库引擎，还可以针对不同的表设置不同的数据引擎，只需要在创建表的时候指定 engine=引擎名称即可

#### 2. MySQL 的优化方案有哪些？

MySQL 数据库常见的优化手段分为三个层面：SQL 和索引优化、数据库结构优化、系统硬件优化等，然而每个大的方向中又包含多个小的优化点。

##### 1.SQL 和索引优化

**① 使用正确的索引**

在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，在 MySQL 5.0 之后的版本中引入了索引合并，简单来说就是把多条件查询，比如 or 或 and 查询的结果集进行合并交集或并集的功能，因此就不会导致索引失效的问题了。

避免在 where 查询条件中使用 != 或者 <> 操作符，因为这些操作符会导致查询引擎放弃索引而进行全表扫描。

适当使用前缀索引，比如邮箱，手机号等有规律的字段。

**② 查询具体的字段而非全部字段**

要尽量避免使用 select *，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力。

**③ 优化子查询**

尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，但 Join 语句并不会创建临时表，因此性能会更高。

**④ 注意查询结果集**

我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表。

**⑤ 不要在列上进行运算操作**

不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率。

**⑥ 适当增加冗余字段**

增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略。

##### 2.数据库结构优化

**① 最小数据长度**

一般说来数据库的表越小，那么它的查询速度就越快，因此为了提高表的效率，应该将表的字段设置的尽可能小，比如身份证号，可以设置为 char(18) 就不要设置为 varchar(18)。

**② 使用最简单数据类型**

能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高。

**③ 尽量少定义 text 类型**

text 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率。

**④ 适当分表、分库策略**

分表和分库方案也是我们经常说的垂直分隔（分表）和水平分隔（分库）。

分表是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率。

分库是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率。

##### 3.硬件优化

MySQL 对硬件的要求主要体现在三个方面：磁盘、网络和内存。

**① 磁盘**

磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率。

磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样。

**② 网络**

保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率。

**③ 内存**

MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率。

#### 3. 

### Redis

#### 1. Redis 数据持久化有几种方式？

持久化功能是 Redis 和 Memcached 的主要区别之一，因为只有 Redis 提供了此功能。

在 Redis 4.0 之前数据持久化方式有两种：AOF 方式和 RDB 方式。

RDB（Redis DataBase，快照方式）是将某一个时刻的内存数据，以二进制的方式写入磁盘。
AOF（Append Only File，文件追加方式）是指将所有的操作命令，以文本的形式追加到文件中。
RDB 默认的保存文件为 dump.rdb，优点是以二进制存储的，因此占用的空间更小、数据存储更紧凑，并且与 AOF 相比，RDB 具备更快的重启恢复能力。

AOF 默认的保存文件为 appendonly.aof，它的优点是存储频率更高，因此丢失数据的风险就越低，并且 AOF 并不是以二进制存储的，所以它的存储信息更易懂。缺点是占用空间大，重启之后的数据恢复速度比较慢。

可以看出 RDB 和 AOF 各有利弊，RDB 具备更快速的数据重启恢复能力，并且占用更小的磁盘空间，但有数据丢失的风险；而 AOF 文件的可读性更高，但却占用了更大的空间，且重启之后的恢复速度更慢，于是在 Redis 4.0 就推出了混合持久化的功能。

混合持久化的功能指的是 Redis 可以使用 RDB + AOF 两种格式来进行数据持久化，这样就可以做到扬长避短物尽其用了。

## 系统设计

### 高可用

#### 1. 如何保证接口的幂等性？常见的实现方案有哪些？

1. 前端拦截
2. 使用数据库实现幂等性
	1. 通过悲观锁来实现幂等性
	2. 通过唯一索引来实现幂等性
	3. 通过乐观锁来实现幂等性
3. 使用 JVM 锁实现幂等性
	1. JVM 提供的内置锁如 Lock 或者是 synchronized 来实现幂等性
4. 使用分布式锁实现幂等性


### 分布式

#### 1. Nginx 主要的负载均衡策略

1. 轮询策略（默认负载均衡策略）
2. 最少连接数负载均衡策略
3. ip-hash 负载均衡策略
4. 权重负载均衡策略

#### 2. 分布式锁的常见实现方式

1. 基于 MySQL 的悲观锁来实现分布式锁，这种方式使用的最少，因为这种实现方式的性能不好，且容易造成死锁；
2. 基于 Memcached 实现分布式锁，可使用 add 方法来实现，如果添加成功了则表示分布式锁创建成功；
3. 基于 Redis 实现分布式锁，使用 setnx 方法来实现；
4. 基于 ZooKeeper 实现分布式锁，利用 ZooKeeper 顺序临时节点来实现。

## 常用框架

### Spring

#### 1. Spring Bean 的生命周期

Bean 的生命周期主要包含以下 5 个流程：

1. 实例化：为 Bean 分配内存空间；
2. 设置属性：将当前类依赖的 Bean 属性，进行注入和装配；
3. 初始化：
	1.  执行各种通知。
	2.  执行初始化的前置方法。
	3.  执行初始化方法。
	4.  执行初始化的后置方法。
4. 使用 Bean：在程序中使用 Bean 对象；
5. 销毁 Bean：将 Bean 对象进行销毁操作。

![[Pasted image 20230424165742.png]]

#### 2. Bean 的注册方式

1. XML 配置文件的注册方式：bean id
2. Java 注解的注册方式：@Component 或 @Bean
3. Java API 的注册方式： BeanDefinitionRegistry

### 3. Spring IoC 的优点

1. 使用更方便，拿来即用，无需显式的创建和销毁的过程；
2. 可以很容易提供众多服务，比如事务管理、消息服务等；
3. 提供了单例模式的支持；
4. 提供了 AOP 抽象，利用它很容易实现权限拦截、运行期监控等功能；
5. 更符合面向对象的设计法则；
6. 低侵入式设计，代码的污染极低，降低了业务对象替换的复杂性。

#### 4. SpringBoot 有哪些优点？

更快速的构建能力、起步依赖、内嵌容器支持、Actuator 监控支持等。

#### 5. Spring Boot 的启动流程

1. 创建并启动计时监控类
2. 声明应用上下文对象和异常报告集合，此过程声明了应用上下文对象和一个异常报告的 ArrayList 集合。
3. 设置系统属性 headless 的值，设置 Java.awt.headless = true，其中 awt（Abstract Window Toolkit）的含义是抽象窗口工具集。设置为 true 表示运行一个 headless 服务器，可以用它来作一些简单的图像处理。
4. 创建所有 Spring 运行监听器并发布应用启动事件，此过程用于获取配置的监听器名称并实例化所有的类。
5. 初始化默认应用的参数类，也就是说声明并创建一个应用参数对象。
6. 准备环境，创建配置并且绑定环境（通过 property sources 和 profiles 等配置文件）。
7. 创建 Banner 的打印类
8. 创建应用上下文，根据不同的应用类型来创建不同的 ApplicationContext 上下文对象。
9. 实例化异常报告器，它调用的是 getSpringFactoriesInstances() 方法来获取配置异常类的名称，并实例化所有的异常处理类。
10. 准备应用上下文，此方法的主要作用是把上面已经创建好的对象，传递给 prepareContext 来准备上下文，例如将环境变量 environment 对象绑定到上下文中、配置 bean 生成器以及资源加载器、记录启动日志等操作。
11. 刷新应用上下文，此方法用于解析配置文件，加载 bean 对象，并且启动内置的 web 容器等操作。
12. 应用上下文刷新之后的事件处理，这个方法的源码是空的，可以做一些自定义的后置处理操作。
13. 停止计时监控类，停止此过程第一步中的程序计时器，并统计任务的执行信息。
14. 输出日志信息，把相关的记录信息，如类名、时间等信息进行控制台输出。
15. 发布应用上下文启动完成事件，触发所有 SpringApplicationRunListener 监听器的 started 事件方法。
16. 执行所有 Runner 运行器，执行所有的 ApplicationRunner 和 CommandLineRunner 运行器。
17. 发布应用上下文就绪事件，触发所有的 SpringApplicationRunListener 监听器的 running 事件。
18. 返回应用上下文对象，到此为止 Spring Boot 的启动程序就结束了，我们就可以正常来使用 Spring Boot 框架了。



### MyBatis

#### 1. MyBatis 使用了哪些设计模式？

1. 工厂模式
工厂模式就是提供一个工厂类，当有客户端需要调用的时候，只调用这个工厂类就可以得到自己想要的结果，从而无需关注某类的具体实现过程。

工厂模式在 MyBatis 中的典型代表是 SqlSessionFactory。

SqlSession 是 MyBatis 中的重要 Java 接口，可以通过该接口来执行 SQL 命令、获取映射器示例和管理事务，而 SqlSessionFactory 正是用来产生 SqlSession 对象的，所以它在 MyBatis 中是比较核心的接口之一。

工厂模式应用解析：SqlSessionFactory 是一个接口类，它的子类 DefaultSqlSessionFactory 有一个 openSession(ExecutorType execType) 的方法，其中使用了工厂模式

2. 建造者模式（Builder）
建造者模式指的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。也就是说建造者模式是通过多个模块一步步实现了对象的构建，相同的构建过程可以创建不同的产品。

例如，组装电脑，最终的产品就是一台主机，然而不同的人对它的要求是不同的，比如设计人员需要显卡配置高的；而影片爱好者则需要硬盘足够大的（能把视频都保存起来），但对于显卡却没有太大的要求，我们的装机人员根据每个人不同的要求，组装相应电脑的过程就是建造者模式。

建造者模式在 MyBatis 中的典型代表是 SqlSessionFactoryBuilder。

普通的对象都是通过 new 关键字直接创建的，但是如果创建对象需要的构造参数很多，且不能保证每个参数都是正确的或者不能一次性得到构建所需的所有参数，那么就需要将构建逻辑从对象本身抽离出来，让对象只关注功能，把构建交给构建类，这样可以简化对象的构建，也可以达到分步构建对象的目的，而 SqlSessionFactoryBuilder 的构建过程正是如此。

在 SqlSessionFactoryBuilder 中构建 SqlSessionFactory 对象的过程是这样的，首先需要通过 XMLConfigBuilder 对象读取并解析 XML 的配置文件，然后再将读取到的配置信息存入到 Configuration 类中，然后再通过 build 方法生成我们需要的 DefaultSqlSessionFactory 对象

3. 单例模式
单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，此模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为单例类。

单例模式也比较好理解，比如一个人一生当中只能有一个真实的身份证号，每个收费站的窗口都只能一辆车子一辆车子的经过，类似的场景都是属于单例模式。

单例模式在 MyBatis 中的典型代表是 ErrorContext。

ErrorContext 是线程级别的的单例，每个线程中有一个此对象的单例，用于记录该线程的执行环境的错误信息。

4. 适配器模式
适配器模式是指将一个不兼容的接口转换成另一个可以兼容的接口，这样就可以使那些不兼容的类可以一起工作。

例如，最早之前我们用的耳机都是圆形的，而现在大多数的耳机和电源都统一成了方形的 typec 接口，那之前的圆形耳机就不能使用了，只能买一个适配器把圆形接口转化成方形的。

而这个转换头就相当于程序中的适配器模式，适配器模式在 MyBatis 中的典型代表是 Log。

MyBatis 中的日志模块适配了多种日志类型：SLF4J、Apache Commons Logging、Log4j、JDK logging


5. 代理模式
代理模式指的是给某一个对象提供一个代理对象，并由代理对象控制原对象的调用。

代理模式在生活中也比较常见，比如我们常见的超市、小卖店其实都是一个个“代理”，他们的最上游是一个个生产厂家，他们这些代理负责把厂家生产出来的产品卖出去。

代理模式在 MyBatis 中的典型代表是 MapperProxyFactory。

MapperProxyFactory 的 newInstance() 方法就是生成一个具体的代理来实现功能的

6. 模板方法模式
模板方法模式是最常用的设计模式之一，它是指定义一个操作算法的骨架，而将一些步骤的实现延迟到子类中去实现，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。此模式是基于继承的思想实现代码复用的。

模板方法在 MyBatis 中的典型代表是 BaseExecutor。

在 MyBatis 中 BaseExecutor 实现了大部分 SQL 执行的逻辑，然后再把几个方法交给子类来实现

7. 装饰器模式
装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有类的一个包装。

装饰器模式在生活中很常见，比如装修房子，我们在不改变房子结构的同时，给房子添加了很多的点缀；比如安装了天然气报警器，增加了热水器等附加的功能都属于装饰器模式。

装饰器模式在 MyBatis 中的典型代表是 Cache。

Cache 除了有数据存储和缓存的基本功能外（由 PerpetualCache 永久缓存实现），还有其他附加的 Cache 类，比如先进先出的 FifoCache、最近最少使用的 LruCache、防止多线程并发访问的 SynchronizedCache 等众多附加功能的缓存类。


## 算法

### 1. 从一亿个ip找出出现次数最多的IP(分治法)

1,[hash](https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020)散列  
2,找到每个块出现次数最多的(默认出现均匀)—–>可以用字典树  
3,在每个块出现最多的数据中挑选出最大的为结果